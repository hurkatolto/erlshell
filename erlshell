#!/usr/bin/env escript -c

main(_Opts) ->
    recompile_sources(),
    read_lines(1).

read_lines(L) ->
    case io:get_line(integer_to_list(L) ++ "> ") of
        eof -> ok;
        Line ->  
            exec_line(Line),
            read_lines(L + 1)
    end.

exec_line(Line0) ->
    try
        Line = chunk_nl(Line0),
        {ok, Tokens, _} = calc:string(Line),
        io:format("Tokens = ~p\n", [Tokens]),
        Tokens1 = lists:foldl(fun(Op, Acc) ->
                        delete_operators_between(Acc, Op)
                    end, Tokens, ['"', '\'']),
        io:format("Tokens1 = ~p~n", [Tokens1]),
        {ok, Result} = calc_parser:parse(Tokens1),
        io:format("~p\n", [Result])
    catch _:Error ->
        io:format("Error: ~p,\nStack = ~p\n", [Error, erlang:get_stacktrace()])
    end.

recompile_sources() ->
    {ok, _} = leex:file("calc.xrl"),
    compile:file("calc"),
    {ok, _} = yecc:file("calc_parser.yrl"),
    compile:file("calc_parser").

delete_operators_between(Tokens, _Operator) ->
    Tokens.
%    dob(Tokens, Operator, [], false).

%dob([], _Op, Res, InOp) ->
%    lists:reverse(Res);
%dob([{O, _} = Tok | T], Op, Res, false) when O =:= Op ->
%    dob(T, Op, [Tok | Res], true);
%dob([Tok | T], Op, Res, false) ->
%    dob(T, Op, [Tok | Res], 
%dob([{

chunk_nl(L) ->
    case string:tokens(L, "\n") of
        [Line] -> Line;
        [] -> []
    end.
